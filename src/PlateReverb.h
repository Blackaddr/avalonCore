/*
 * Company: HexeFX
 * Effect Name: Plate Reverb
 * Description: A lush sounding plate reverb. Open-source @ github.com/hexeguitar/t40fx.
 *
 * This file was auto-generated by Blackaddr Audio STRIDE Compiler.
 */
#pragma once

#include <arm_math.h>
#include "Audio.h"
#include "Stride/AudioEffectWrapper.h"

//!s - START_USER_INCLUDES - put your #includes below this line before the matching END

// if uncommented will place all the buffers in the DMAMEM section ofd the memory
// works with single instance of the reverb only
#define REVERB_USE_DMAMEM

/***
 * Loop delay modulation: comment/uncomment to switch sin/cos
 * modulation for the 1st or 2nd tap, 3rd tap is always modulated
 * more modulation means more chorus type sounding reverb tail
 */
//#define TAP1_MODULATED
#define TAP2_MODULATED

#ifdef REVERB_USE_DMAMEM
#define MEM_TYPE DMAMEM
#else
#define MEM_TYPE
#endif

//!e - END_USER_INCLUDES

namespace HexeFX_PlateReverb {

//!s - START_USER_EFFECT_TYPES - put your effect types below this line before the matching END
//!e - END_USER_EFFECT_TYPES

class PlateReverb : public AudioStream, public Stride::AudioEffectWrapper {
public:
    static constexpr unsigned NUM_INPUTS  = 2;
    static constexpr unsigned NUM_OUTPUTS = 2;

    // List of effect control names
    enum {
        Bypass_e = 0,
        Reverb_e = 1,
        Tone_e = 2,
        WetMix_e = 3,
        Echo_e = 4,
        LowCut_e = 5,
        HighCut_e = 6,
        Volume_e = 7,
        OutputMode_e = 8,
        NUM_CONTROLS
    };

    //!s - START_USER_CLASS_TYPES - put your custom class types below this line before the matching END
    //!e - END_USER_CLASS_TYPES

    PlateReverb();

    //!s - START_USER_CONSTRUCTORS - put your custom constructors below this line before the matching END
    //!e - END_USER_CONSTRUCTORS

    virtual ~PlateReverb();

    // Standard EFX interface functions - do not change these declaration
    virtual void update(); // main audio processing loop function
    void mapMidiControl(int parameter, int midiCC, int midiChannel = 0) override;
    void processMidi(int channel, int midiCC, int value) override;
    void setParam(int paramIndex, float paramValue) override;
    float getUserParamValue(int paramIndex, float normalizedParamValue);
    const char* getName() override;
    const uint8_t* getRblk() override;

    // control value set functions, must take floats between 0.0f and 1.0f - do not change these declarations
    void reverb(float value);
    void tone(float value);
    void wetmix(float value);
    void echo(float value);
    void lowcut(float value);
    void highcut(float value);
    void volume(float value) override;
    void outputmode(float value);

    //!s - START_USER_PUBLIC_MEMBERS - put your public members below this line before the matching END
    //!e - END_USER_PUBLIC_MEMBERS

private:
    audio_block_t *m_inputQueueArray[2]; // required by AudioStream base class, array size is num inputs
    int m_midiConfig[NUM_CONTROLS][2]; // stores the midi parameter mapping

    // m_bypass and m_volume are already provided by the base class AudioEffectWrapper
    float m_reverb = 0.0f;
    float m_tone = 0.0f;
    float m_wetmix = 0.0f;
    float m_echo = 0.0f;
    float m_lowcut = 0.0f;
    float m_highcut = 0.0f;
    float m_outputmode = 0.0f;

    audio_block_t* m_basicInputCheck(audio_block_t* inputAudioBlock, unsigned outputChannel);

    //!s - START_USER_PRIVATE_MEMBERS - put your private members below this line before the matching END

    // Other functions
    void m_clearMemories();
    void m_cleanup();
    void m_postProcessing(audio_block_t *out, audio_block_t *dry, audio_block_t *wet);
    void size(float n);
    void hidamp(float n);
    void lodamp(float n);
    void lowpass(float n);
    void diffusion(float n);
    float32_t get_size(void) {return rv_time_k;}

    // Other Variables
    float32_t input_attn;

    float32_t in_allp_k; // input allpass coeff (default 0.6)
    uint16_t in_allp1_idxL;
    uint16_t in_allp2_idxL;
    uint16_t in_allp3_idxL;
    uint16_t in_allp4_idxL;

    float32_t in_allp_out_L;    // L allpass chain output
    uint16_t in_allp1_idxR;
    uint16_t in_allp2_idxR;
    uint16_t in_allp3_idxR;
    uint16_t in_allp4_idxR;

    float32_t in_allp_out_R;    // R allpass chain output
    uint16_t lp_allp1_idx;
    uint16_t lp_allp2_idx;
    uint16_t lp_allp3_idx;
    uint16_t lp_allp4_idx;

    float32_t loop_allp_k;         // loop allpass coeff (default 0.6)
    float32_t lp_allp_out;
    uint16_t lp_dly1_idx;
    uint16_t lp_dly2_idx;
    uint16_t lp_dly3_idx;
    uint16_t lp_dly4_idx;

    float32_t lp_hidamp_k;       // loop high band damping coeff
    float32_t lp_lodamp_k;       // loop low baand damping coeff

    float32_t lpf1;             // lowpass filters
    float32_t lpf2;
    float32_t lpf3;
    float32_t lpf4;

    float32_t hpf1;             // highpass filters
    float32_t hpf2;
    float32_t hpf3;
    float32_t hpf4;

    float32_t lp_lowpass_f;      // loop lowpass scaled frequency
    float32_t lp_hipass_f;       // loop highpass scaled frequency

    float32_t master_lowpass_f;
    float32_t master_lowpass_l;
    float32_t master_lowpass_r;

    const float32_t rv_time_k_max = 0.95f;
    float32_t rv_time_k = 0.0f;         // reverb time coeff
    float32_t rv_time_scaler = 0.0f; // with high lodamp settings lower the max reverb time to avoid clipping

    uint32_t lfo1_phase_acc;     // LFO 1
    uint32_t lfo1_adder;
    uint32_t lfo2_phase_acc;    // LFO 2
    uint32_t lfo2_adder;

    //!e - END_USER_PRIVATE_MEMBERS

};

}
