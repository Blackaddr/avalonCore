/*
 * Company: Blackaddr Audio
 * Effect Name: Tremolo
 * Description: An easy to use tremolo with mulitple modulation waveforms to choose from.
 *
 * This file was auto-generated by Blackaddr Audio STRIDE Compiler.
 */
#include <cmath>
#include "Tremolo.h"
#include "Stride/EfxPrint.h"

using namespace Stride;

namespace BlackaddrAudio_Tremolo {

Tremolo::Tremolo()
: AudioStream(NUM_INPUTS, m_inputQueueArray)
{
    m_osc.setWaveform(m_waveformType);
    m_osc.setRoundnessFactor(0.01f);
}

Tremolo::~Tremolo()
{
    // perform any necessary clean up here, though destructors are not
    // called on the hardware, only in the simulator.
}

void Tremolo::update(void)
{
    audio_block_t *inputAudioBlock = receiveWritable(); // get the next block of input samples
    inputAudioBlock = m_basicInputCheck(inputAudioBlock, 0); // check for disable mode, bypass, or invalid inputs. Transmit to channel 0 in bypass
    if (!inputAudioBlock) { return; } // no further processing for this update() call

    // You must call m_updateInputPeak() before processing the audio
    m_updateInputPeak(inputAudioBlock);

    // DO AUDIO EFFECT PROCESSING
    // apply modulation wave
    float *mod = m_osc.getNextVector();
    for (auto i=0; i<AUDIO_BLOCK_SAMPLES; i++) {
        mod[i] = (mod[i] + 1.0f) / 2.0f; // convert from [-1.0,1.0] to [0.0,1.0]
        mod[i] = (1.0f - m_depth) + mod[i]*m_depth;
        mod[i] = (m_volume) * mod[i];
        float sample = std::roundf(mod[i] * (float)inputAudioBlock->data[i]);
        inputAudioBlock->data[i] = (int16_t)sample;
    }

    m_updateOutputPeak(inputAudioBlock); // you must call m_upateOutputPeak() at the end of update() before transmit
    transmit(inputAudioBlock);
    release(inputAudioBlock);
}

void Tremolo::setWaveform(Waveform waveform)
{
    m_waveformType = waveform;
    m_osc.setWaveform(waveform);
}

void Tremolo::waveform(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_waveform = value;
    unsigned unsignedValue = static_cast<unsigned>(std::roundf(value * static_cast<float>(4))); // number of supported waveforms minus one

    switch (unsignedValue) {
    case 0 : m_waveformType = Stride::Waveform::SINE; break;
    case 1 : m_waveformType = Stride::Waveform::TRIANGLE; break;
    case 2 : m_waveformType = Stride::Waveform::SQUARE; break;
    case 3 : m_waveformType = Stride::Waveform::SAWTOOTH; break;
    case 4 : m_waveformType = Stride::Waveform::RANDOM; break;
    default : m_waveformType = Stride::Waveform::SINE; break;
    }
    setWaveform(static_cast<Stride::Waveform>(m_waveformType));
}

void Tremolo::rate(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_rate = value;
    float rateAudioBlock = m_rate * MAX_RATE_HZ;
    m_osc.setRateAudio(rateAudioBlock);
}

void Tremolo::depth(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_depth = value;
}

void Tremolo::volume(float value)
{
    volumeDb(-40.0f + (value * 50.0f)); // volume knob goes from -40dB to +10dB
}


}
