/*
 * Company: HexeFX
 * Effect Name: Plate Reverb
 * Description: A lush sounding plate reverb.Open-source @ github.com/hexeguitar/t40fx.
 *
 * This file was auto-generated by Blackaddr Audio STRIDE Compiler.
 */
#include "Stride/EfxPrint.h"
#include "Stride/LibBasicFunctions.h"
#include "Stride/Compatability.h"
#include "PlateReverb.h"

using namespace Stride;

namespace HexeFX_PlateReverb {

#define INP_ALLP_COEFF      (0.65f)
#define LOOP_ALLOP_COEFF    (0.65f)

#define HI_LOSS_FREQ        (0.3f)
#define HI_LOSS_FREQ_MAX    (0.08f)
#define LO_LOSS_FREQ        (0.06f)

#define LFO_AMPL_BITS       (5)                             // 2^LFO_AMPL_BITS will be the LFO amplitude
#define LFO_AMPL            ((1<<LFO_AMPL_BITS) + 1)        // lfo amplitude
#define LFO_READ_OFFSET     (LFO_AMPL>>1)                   // read offset = half the amplitude
#define LFO_FRAC_BITS       (16 - LFO_AMPL_BITS)            // fractional part used for linear interpolation
#define LFO_FRAC_MASK       ((1<<LFO_FRAC_BITS)-1)          // mask for the above

#define LFO1_FREQ_HZ        (1.37f)                          // LFO1 frequency in Hz
#define LFO2_FREQ_HZ        (1.52f)                          // LFO2 frequency in Hz

#define RV_MASTER_LOWPASS_F (0.6f)                           // master lowpass scaled frequency coeff.

constexpr int16_t AudioWaveformSine[257] = {
     0,   804,  1608,  2410,  3212,  4011,  4808,  5602,  6393,  7179,
  7962,  8739,  9512, 10278, 11039, 11793, 12539, 13279, 14010, 14732,
 15446, 16151, 16846, 17530, 18204, 18868, 19519, 20159, 20787, 21403,
 22005, 22594, 23170, 23731, 24279, 24811, 25329, 25832, 26319, 26790,
 27245, 27683, 28105, 28510, 28898, 29268, 29621, 29956, 30273, 30571,
 30852, 31113, 31356, 31580, 31785, 31971, 32137, 32285, 32412, 32521,
 32609, 32678, 32728, 32757, 32767, 32757, 32728, 32678, 32609, 32521,
 32412, 32285, 32137, 31971, 31785, 31580, 31356, 31113, 30852, 30571,
 30273, 29956, 29621, 29268, 28898, 28510, 28105, 27683, 27245, 26790,
 26319, 25832, 25329, 24811, 24279, 23731, 23170, 22594, 22005, 21403,
 20787, 20159, 19519, 18868, 18204, 17530, 16846, 16151, 15446, 14732,
 14010, 13279, 12539, 11793, 11039, 10278,  9512,  8739,  7962,  7179,
  6393,  5602,  4808,  4011,  3212,  2410,  1608,   804,     0,  -804,
 -1608, -2410, -3212, -4011, -4808, -5602, -6393, -7179, -7962, -8739,
 -9512,-10278,-11039,-11793,-12539,-13279,-14010,-14732,-15446,-16151,
-16846,-17530,-18204,-18868,-19519,-20159,-20787,-21403,-22005,-22594,
-23170,-23731,-24279,-24811,-25329,-25832,-26319,-26790,-27245,-27683,
-28105,-28510,-28898,-29268,-29621,-29956,-30273,-30571,-30852,-31113,
-31356,-31580,-31785,-31971,-32137,-32285,-32412,-32521,-32609,-32678,
-32728,-32757,-32767,-32757,-32728,-32678,-32609,-32521,-32412,-32285,
-32137,-31971,-31785,-31580,-31356,-31113,-30852,-30571,-30273,-29956,
-29621,-29268,-28898,-28510,-28105,-27683,-27245,-26790,-26319,-25832,
-25329,-24811,-24279,-23731,-23170,-22594,-22005,-21403,-20787,-20159,
-19519,-18868,-18204,-17530,-16846,-16151,-15446,-14732,-14010,-13279,
-12539,-11793,-11039,-10278, -9512, -8739, -7962, -7179, -6393, -5602,
 -4808, -4011, -3212, -2410, -1608,  -804,     0
};

// Memory arrays
// Input Allpass Filter sizes
static constexpr size_t INPUT_ALLPASS1_LEFT_SIZE  = 224;
static constexpr size_t INPUT_ALLPASS2_LEFT_SIZE  = 420;
static constexpr size_t INPUT_ALLPASS3_LEFT_SIZE  = 856;
static constexpr size_t INPUT_ALLPASS4_LEFT_SIZE  = 1089;
static constexpr size_t INPUT_ALLPASS1_RIGHT_SIZE = 156;
static constexpr size_t INPUT_ALLPASS2_RIGHT_SIZE = 520;
static constexpr size_t INPUT_ALLPASS3_RIGHT_SIZE = 956;
static constexpr size_t INPUT_ALLPASS4_RIGHT_SIZE = 1289;

// Loop allpass filter and delay sizes
static constexpr size_t LOOP_ALLPASS1_SIZE = 2303;
static constexpr size_t LOOP_ALLPASS2_SIZE = 2905;
static constexpr size_t LOOP_ALLPASS3_SIZE = 3175;
static constexpr size_t LOOP_ALLPASS4_SIZE = 2398;
static constexpr size_t LOOP_DELAY1_SIZE   = 3423;
static constexpr size_t LOOP_DELAY2_SIZE   = 4589;
static constexpr size_t LOOP_DELAY3_SIZE   = 4365;
static constexpr size_t LOOP_DELAY4_SIZE   = 3698;

// Loop delay offsets
static constexpr uint16_t LOOP_DELAY1_OFFSET_LEFT  = 201;
static constexpr uint16_t LOOP_DELAY2_OFFSET_LEFT  = 145;
static constexpr uint16_t LOOP_DELAY3_OFFSET_LEFT  = 1897;
static constexpr uint16_t LOOP_DELAY4_OFFSET_LEFT  = 280;
static constexpr uint16_t LOOP_DELAY1_OFFSET_RIGHT = 1897;
static constexpr uint16_t LOOP_DELAY2_OFFSET_RIGHT = 1245;
static constexpr uint16_t LOOP_DELAY3_OFFSET_RIGHT = 487;
static constexpr uint16_t LOOP_DELAY4_OFFSET_RIGHT = 780;

static constexpr uint16_t lp_dly1_offset_L = LOOP_DELAY1_OFFSET_LEFT;
static constexpr uint16_t lp_dly2_offset_L = LOOP_DELAY2_OFFSET_LEFT;
static constexpr uint16_t lp_dly3_offset_L = LOOP_DELAY3_OFFSET_LEFT;
static constexpr uint16_t lp_dly4_offset_L = LOOP_DELAY4_OFFSET_LEFT;

static constexpr uint16_t lp_dly1_offset_R = LOOP_DELAY1_OFFSET_RIGHT;
static constexpr uint16_t lp_dly2_offset_R = LOOP_DELAY1_OFFSET_RIGHT;
static constexpr uint16_t lp_dly3_offset_R = LOOP_DELAY1_OFFSET_RIGHT;
static constexpr uint16_t lp_dly4_offset_R = LOOP_DELAY1_OFFSET_RIGHT;

// Memory arrays
float32_t MEM_TYPE input_blockL[AUDIO_BLOCK_SAMPLES];
float32_t MEM_TYPE input_blockR[AUDIO_BLOCK_SAMPLES];

// Input allpass filters
float32_t MEM_TYPE in_allp1_bufL[INPUT_ALLPASS1_LEFT_SIZE]; // input allpass buffers
float32_t MEM_TYPE in_allp2_bufL[INPUT_ALLPASS2_LEFT_SIZE];
float32_t MEM_TYPE in_allp3_bufL[INPUT_ALLPASS3_LEFT_SIZE];
float32_t MEM_TYPE in_allp4_bufL[INPUT_ALLPASS4_LEFT_SIZE];
float32_t MEM_TYPE in_allp1_bufR[INPUT_ALLPASS1_RIGHT_SIZE]; // input allpass buffers
float32_t MEM_TYPE in_allp2_bufR[INPUT_ALLPASS2_RIGHT_SIZE];
float32_t MEM_TYPE in_allp3_bufR[INPUT_ALLPASS3_RIGHT_SIZE];
float32_t MEM_TYPE in_allp4_bufR[INPUT_ALLPASS4_RIGHT_SIZE];

// Loop allpass filters
float32_t MEM_TYPE lp_allp1_buf[LOOP_ALLPASS1_SIZE]; // loop allpass buffers
float32_t MEM_TYPE lp_allp2_buf[LOOP_ALLPASS2_SIZE];
float32_t MEM_TYPE lp_allp3_buf[LOOP_ALLPASS3_SIZE];
float32_t MEM_TYPE lp_allp4_buf[LOOP_ALLPASS4_SIZE];

// Loop delay lines
float32_t MEM_TYPE lp_dly1_buf[LOOP_DELAY1_SIZE];
float32_t MEM_TYPE lp_dly2_buf[LOOP_DELAY2_SIZE];
float32_t MEM_TYPE lp_dly3_buf[LOOP_DELAY3_SIZE];
float32_t MEM_TYPE lp_dly4_buf[LOOP_DELAY4_SIZE];

////////////////////////////////////////////////////////////////////////////////
const int16_t ZERO_AUDIO_BLOCK[AUDIO_BLOCK_SAMPLES] = {0};
constexpr audio_block_t zeroblock = {0, 0, 0,  (int16_t*)ZERO_AUDIO_BLOCK};


PlateReverb::PlateReverb()
: AudioStream(NUM_INPUTS, m_inputQueueArray)
{
    ////////////////////////////////////////////////////////////////////////////
    input_attn = 0.5f;
    in_allp_k = INP_ALLP_COEFF;

    m_clearMemories();  // zero all the memories

    // reset the memory indices and outputs

    // input allpass filters
    in_allp1_idxL = 0; // integer
    in_allp2_idxL = 0;
    in_allp3_idxL = 0;
    in_allp4_idxL = 0;
    in_allp_out_L = 0.0f; // float
    in_allp1_idxR = 0;
    in_allp2_idxR = 0;
    in_allp3_idxR = 0;
    in_allp4_idxR = 0;
    in_allp_out_R = 0.0f;

    // loop filters
    lp_allp1_idx = 0;
    lp_allp2_idx = 0;
    lp_allp3_idx = 0;
    lp_allp4_idx = 0;
    loop_allp_k = LOOP_ALLOP_COEFF;
    lp_allp_out = 0.0f;

    // loop delay lines
    lp_dly1_idx = 0;
    lp_dly2_idx = 0;
    lp_dly3_idx = 0;
    lp_dly4_idx = 0;

    lp_hidamp_k = 1.0f;
    lp_lodamp_k = 0.0f;

    lp_lowpass_f = HI_LOSS_FREQ;
    lp_hipass_f = LO_LOSS_FREQ;

    lpf1 = 0.0f;
    lpf2 = 0.0f;
    lpf3 = 0.0f;
    lpf4 = 0.0f;

    hpf1 = 0.0f;
    hpf2 = 0.0f;
    hpf3 = 0.0f;
    hpf4 = 0.0f;

    master_lowpass_f = RV_MASTER_LOWPASS_F;
    master_lowpass_l = 0.0f;
    master_lowpass_r = 0.0f;

    // LFOs are integer
    lfo1_phase_acc = 0;
    lfo1_adder = (UINT32_MAX + 1)/(AUDIO_SAMPLE_RATE_HZ * LFO1_FREQ_HZ);
    lfo2_phase_acc = 0;
    lfo2_adder = (UINT32_MAX + 1)/(AUDIO_SAMPLE_RATE_HZ * LFO2_FREQ_HZ);
}

PlateReverb::~PlateReverb()
{
    // perform any necessary clean up here, though destructors are not
    // called on the hardware, only in the simulator.
}

void PlateReverb::m_clearMemories()
{
    memset(in_allp1_bufL, 0, sizeof(in_allp1_bufL));
    memset(in_allp2_bufL, 0, sizeof(in_allp2_bufL));
    memset(in_allp3_bufL, 0, sizeof(in_allp3_bufL));
    memset(in_allp4_bufL, 0, sizeof(in_allp4_bufL));

    memset(in_allp1_bufR, 0, sizeof(in_allp1_bufR));
    memset(in_allp2_bufR, 0, sizeof(in_allp2_bufR));
    memset(in_allp3_bufR, 0, sizeof(in_allp3_bufR));
    memset(in_allp4_bufR, 0, sizeof(in_allp4_bufR));

    memset(lp_allp1_buf, 0, sizeof(lp_allp1_buf));
    memset(lp_allp2_buf, 0, sizeof(lp_allp2_buf));
    memset(lp_allp3_buf, 0, sizeof(lp_allp3_buf));
    memset(lp_allp4_buf, 0, sizeof(lp_allp4_buf));

    memset(lp_dly1_buf, 0, sizeof(lp_dly1_buf));
    memset(lp_dly2_buf, 0, sizeof(lp_dly2_buf));
    memset(lp_dly3_buf, 0, sizeof(lp_dly3_buf));
    memset(lp_dly4_buf, 0, sizeof(lp_dly4_buf));
}

void PlateReverb::m_cleanup()
{
    static bool cleanup_done = false;
    // handle bypass, 1st call will clean the buffers to avoid continuing the previous reverb tail
    if (m_bypass)
    {
        if (!cleanup_done)
        {
            m_clearMemories();
            cleanup_done = true;
        }
        return;
    }
    cleanup_done = false;
}

void updateLfo(uint32_t& lfo_phase_acc, uint32_t& lfo_adder, int16_t& lfo_out_sin, int16_t& lfo_out_cos)
{
    uint32_t idx;
    int32_t y0, y1;
    int64_t y;

    lfo_phase_acc += lfo_adder;
    idx = lfo_phase_acc >> 24;     // 8bit lookup table address
    y0 =  AudioWaveformSine[idx];
    y1 = AudioWaveformSine[idx+1];
    idx = lfo_phase_acc & 0x00FFFFFF;   // lower 24 bit = fractional part
    y = (int64_t)y0 * (0x00FFFFFF - idx);
    y += (int64_t)y1 * idx;
    lfo_out_sin = (int32_t) (y >> (32-8)); // 16bit output

    idx = ((lfo_phase_acc >> 24)+64) & 0xFF;
    y0 = AudioWaveformSine[idx];
    y1 = AudioWaveformSine[idx + 1];
    y = (int64_t)y0 * (0x00FFFFFF - idx);
    y += (int64_t)y1 * idx;
    lfo_out_cos = (int32_t) (y >> (32-8)); // 16bit output
}

float32_t allpass(float32_t* input_allpass_buffer, const size_t buffer_size, uint16_t& buffer_index,
                       float32_t input, const float32_t allpass_coeff_k)
{
    float32_t acc;
    acc = input_allpass_buffer[buffer_index]  + input * allpass_coeff_k;
    input_allpass_buffer[buffer_index] = input - allpass_coeff_k * acc;

    // increment the buffer index and rollover if necessary
    if (++buffer_index >= buffer_size) { buffer_index = 0; }

    return acc;
}

float32_t loopDelay(float32_t* loop_delay_buf, const size_t buffer_size, uint16_t& buffer_index,
                    float32_t input)
{
    float32_t delay_output = loop_delay_buf[buffer_index];    // get previous value from loop delay (end of the delay)
    loop_delay_buf[buffer_index] = input;  // update loop delay with the output from the loop allpass filter
    if (++buffer_index >= buffer_size) { buffer_index = 0; }     // update loop delay1 index
    return delay_output;
}

float32_t hiLoFilter(float32_t input, float32_t& lpf, const float32_t lowpass_f, const float32_t lowdamp_k,
                     float32_t& hpf, const float32_t highpass_f, const float32_t hidamp_k,
                     const float32_t reverb_time, const float32_t reverb_time_scaler)
{
    // hi/lo shelving filter
    float32_t temp1 = input - lpf;
    lpf += temp1 * lowpass_f;
    float32_t temp2 = input - lpf;
    temp1 = lpf - hpf;
    hpf += temp1 * highpass_f;
    float32_t output = lpf + temp2*hidamp_k + hpf*lowdamp_k;
    output = output * reverb_time * reverb_time_scaler; // scale by the reveb time
    return output;
}

float32_t modulatedTap(float32_t* loop_delay_buf, const size_t buffer_size, uint16_t& buffer_index, const uint16_t loop_delay_offset,
                       int16_t lfo_mod, float32_t lfo_factor)
{
    uint16_t temp16 = (buffer_index + loop_delay_offset + (lfo_mod>>LFO_FRAC_BITS)) %  buffer_size;
    float32_t temp1 = loop_delay_buf[temp16++];    // sample now
    if (temp16  >= buffer_size) temp16 = 0;
    float32_t temp2 = loop_delay_buf[temp16];    // sample next
    float32_t input = (float32_t)(lfo_mod & LFO_FRAC_MASK) / ((float32_t)LFO_FRAC_MASK); // interp. k
    float32_t output = (temp1*(1.0f-input) + temp2*input)* lfo_factor;
    return output;
}


void PlateReverb::update(void)
{
    audio_block_t *inputAudioBlockL = receiveReadOnly(0); // get the next block of input samples
    audio_block_t *inputAudioBlockR = receiveReadOnly(1);

    inputAudioBlockL = m_basicInputCheck(inputAudioBlockL, 0); // check for disable mode, bypass, or invalid inputs. Transmit to channel 0 in bypass
    inputAudioBlockR = m_basicInputCheck(inputAudioBlockR, 1); // check for disable mode, bypass, or invalid inputs. Transmit to channel 0 in bypass
    if (!inputAudioBlockL && !inputAudioBlockR) { return; } // no further processing for this update() call

    if (!inputAudioBlockR) { inputAudioBlockR = inputAudioBlockL; }  // if no R channel, copy from left channel
    if (!inputAudioBlockL) { inputAudioBlockL = inputAudioBlockR; }  // if no L channel, copy from right channel

    // You must call m_updateInputPeak() before processing the audio
    m_updateInputPeak(inputAudioBlockL);

    ////////////////////////////////////////////////////////////////////////////

    const audio_block_t *blockL, *blockR;

    audio_block_t *outblockL;
    audio_block_t *outblockR;

    float32_t input, acc, tempf32;
    uint16_t temp16;
    float32_t rv_time;

    // for LFOs:
    int16_t lfo1_out_sin, lfo1_out_cos, lfo2_out_sin, lfo2_out_cos;

    blockL = inputAudioBlockL;
    blockR = inputAudioBlockR;
    outblockL = allocate();
    outblockR = allocate();
    if (!outblockL || !outblockR) {  // cleanup on allocation failure
        if (outblockL) release(outblockL);
        if (outblockR) release(outblockR);
        if (blockL) { transmit((audio_block_t *)blockL, 0); release((audio_block_t *)blockL); }
        if (blockR) { transmit((audio_block_t *)blockR, 1); release((audio_block_t *)blockR); }
        return;
    }

    // TODO: these probably aren't needed as we never get here with invalid blocks
    if (!blockL) blockL = &zeroblock;
    if (!blockR) blockR = &zeroblock;

    // convert input audio data to float32
    arm_q15_to_float((q15_t *)blockL->data, input_blockL, AUDIO_SAMPLES_PER_BLOCK);
    arm_q15_to_float((q15_t *)blockR->data, input_blockR, AUDIO_SAMPLES_PER_BLOCK);

    rv_time = rv_time_k;

    for (unsigned i =0; i < AUDIO_SAMPLES_PER_BLOCK; i++)
    {

        // update the LFOs
        updateLfo(lfo1_phase_acc, lfo1_adder, lfo1_out_sin, lfo1_out_cos);
        updateLfo(lfo2_phase_acc, lfo2_adder, lfo2_out_sin, lfo2_out_cos);

        // Chained input allpass filters
        input = input_blockL[i] * input_attn;  // apply input attenuation
        acc = input;
        acc = allpass(in_allp1_bufL, INPUT_ALLPASS1_LEFT_SIZE, in_allp1_idxL, acc, in_allp_k);
        acc = allpass(in_allp2_bufL, INPUT_ALLPASS2_LEFT_SIZE, in_allp2_idxL, acc, in_allp_k);
        acc = allpass(in_allp3_bufL, INPUT_ALLPASS3_LEFT_SIZE, in_allp3_idxL, acc, in_allp_k);
        acc = allpass(in_allp4_bufL, INPUT_ALLPASS4_LEFT_SIZE, in_allp4_idxL, acc, in_allp_k);
        in_allp_out_L = acc;

        input = input_blockR[i] * input_attn;  // apply input attenuation
        acc = input;
        acc = allpass(in_allp1_bufR, INPUT_ALLPASS1_RIGHT_SIZE, in_allp1_idxR, acc, in_allp_k);
        acc = allpass(in_allp2_bufR, INPUT_ALLPASS2_RIGHT_SIZE, in_allp2_idxR, acc, in_allp_k);
        acc = allpass(in_allp3_bufR, INPUT_ALLPASS3_RIGHT_SIZE, in_allp3_idxR, acc, in_allp_k);
        acc = allpass(in_allp4_bufR, INPUT_ALLPASS4_RIGHT_SIZE, in_allp4_idxR, acc, in_allp_k);
        in_allp_out_R = acc;

        // Loop1 all pass uses Right channel allpass as input
        input = lp_allp_out + in_allp_out_R;  // input to loop1 allpass is previous loop output + R channel allpass output
        acc = input;
        acc = allpass(lp_allp1_buf, LOOP_ALLPASS1_SIZE, lp_allp1_idx, acc, loop_allp_k);
        input = loopDelay(lp_dly1_buf, LOOP_DELAY1_SIZE, lp_dly1_idx, acc); // update the loop delay
        acc = hiLoFilter(input, lpf1, lp_lowpass_f, lp_lodamp_k, hpf1, lp_hipass_f, lp_hidamp_k, rv_time, rv_time_scaler);

        // Loop2 allpass uses Loop1 output and left channel allpass as input
        input = acc + in_allp_out_L;
        acc = input;
        acc = allpass(lp_allp2_buf, LOOP_ALLPASS2_SIZE, lp_allp2_idx, acc, loop_allp_k);
        input = loopDelay(lp_dly2_buf, LOOP_DELAY2_SIZE, lp_dly2_idx, acc); // update the loop delay
        acc = hiLoFilter(input, lpf2, lp_lowpass_f, lp_lodamp_k, hpf2, lp_hipass_f, lp_hidamp_k, rv_time, rv_time_scaler);

        // Loop3 allpass uses Loop2 output and Right channel allpass as input
        input = acc + in_allp_out_R;
        acc = input;
        acc = allpass(lp_allp3_buf, LOOP_ALLPASS3_SIZE, lp_allp3_idx, acc, loop_allp_k);
        input = loopDelay(lp_dly3_buf, LOOP_DELAY3_SIZE, lp_dly3_idx, acc); // update the loop delay
        acc = hiLoFilter(input, lpf3, lp_lowpass_f, lp_lodamp_k, hpf3, lp_hipass_f, lp_hidamp_k, rv_time, rv_time_scaler);

        // Loop4 allpass uses Loop3 output and Left channel allpass as input
        input = acc + in_allp_out_L;
        acc = input;
        acc = allpass(lp_allp4_buf, LOOP_ALLPASS4_SIZE, lp_allp4_idx, acc, loop_allp_k);
        input = loopDelay(lp_dly4_buf, LOOP_DELAY4_SIZE, lp_dly4_idx, acc); // update the loop delay
        acc = hiLoFilter(input, lpf4, lp_lowpass_f, lp_lodamp_k, hpf4, lp_hipass_f, lp_hidamp_k, rv_time, rv_time_scaler);

        lp_allp_out = acc;  // Final loop allpass/delay output

        // Left Channel loop delay tap
#ifdef TAP1_MODULATED
        acc = modulatedTap(lp_dly1_buf, LOOP_DELAY1_SIZE, lp_dly1_idx, lp_dly1_offset_L, lfo1_out_cos, 0.8f);
#else
        temp16 = (lp_dly1_idx + lp_dly1_offset_L) % LOOP_DELAY1_SIZE;
        acc = lp_dly1_buf[temp16]* 0.8f;
#endif

#ifdef TAP2_MODULATED
        acc += modulatedTap(lp_dly2_buf, LOOP_DELAY2_SIZE, lp_dly2_idx, lp_dly2_offset_L, lfo1_out_sin, 0.7f);
#else
        temp16 = (lp_dly2_idx + lp_dly2_offset_L) % LOOP_DELAY2_SIZE;
        acc += (temp1*(1.0f-input) + temp2*input)* 0.6f;
#endif

        acc += modulatedTap(lp_dly3_buf, LOOP_DELAY3_SIZE, lp_dly3_idx, lp_dly3_offset_L, lfo2_out_cos, 0.6f);
        acc += modulatedTap(lp_dly4_buf, LOOP_DELAY4_SIZE, lp_dly4_idx, lp_dly4_offset_L, lfo2_out_sin, 0.5f);

        // Master lowpass filter
        tempf32 = acc - master_lowpass_l;
        master_lowpass_l += tempf32 * master_lowpass_f;
        outblockL->data[i] =(int16_t)(master_lowpass_l * 32767.0f); //sat16(output * 30, 0);

        // Right Channel loop delay tap
#ifdef TAP1_MODULATED
        acc = modulatedTap(lp_dly1_buf, LOOP_DELAY1_SIZE, lp_dly1_idx, lp_dly1_offset_R, lfo1_out_sin, 0.8f);
#else
        temp16 = (lp_dly1_idx + lp_dly1_offset_R) % LOOP_DELAY1_SIZE;
        acc = lp_dly1_buf[temp16]* 0.8f;
#endif

#ifdef TAP2_MODULATED
        acc += modulatedTap(lp_dly2_buf, LOOP_DELAY2_SIZE, lp_dly2_idx, lp_dly2_offset_R, lfo1_out_cos, 0.7f);
#else
        temp16 = (lp_dly2_idx + lp_dly2_offset_R) % LOOP_DELAY2_SIZE;
        acc += (temp1*(1.0f-input) + temp2*input)* 0.7f;
#endif

        acc += modulatedTap(lp_dly3_buf, LOOP_DELAY3_SIZE, lp_dly3_idx, lp_dly3_offset_R, lfo2_out_sin, 0.6f);
        acc += modulatedTap(lp_dly4_buf, LOOP_DELAY4_SIZE, lp_dly4_idx, lp_dly4_offset_R, lfo2_out_cos, 0.5f);

        // Master lowpass filter
        tempf32 = acc - master_lowpass_r;
        master_lowpass_r += tempf32 * master_lowpass_f;
        outblockR->data[i] =(int16_t)(master_lowpass_r * 32767.0f);

    }

    m_postProcessing(outblockL, (audio_block_t *)blockL, outblockL);
    m_postProcessing(outblockR, (audio_block_t *)blockR, outblockR);

    // Blend the L+R back to mono
    if (m_outputmode == 0.0f) {  // MONO MODE
        alphaBlend(outblockL, outblockL, outblockR, 0.5f);
        transmit(outblockL, 0);
    } else {  // STEREO MODE
        transmit(outblockL, 0);
        transmit(outblockR, 1);
    }

    m_updateOutputPeak(outblockL);
    release(outblockL);
    release(outblockR);
    if (blockL != &zeroblock) release((audio_block_t *)blockL);
    if (blockR != &zeroblock) release((audio_block_t *)blockR);

}

void PlateReverb::m_postProcessing(audio_block_t *out, audio_block_t *dry, audio_block_t *wet)
{
    if (!out) return; // no valid output buffer

    if ( out && dry && wet) {
        // Simulate the LPF IIR nature of the analog systems
        //m_iir->process(wet->data, wet->data, AUDIO_SAMPLES_PER_BLOCK);
        alphaBlend(out, dry, wet, m_wetmix);
    } else if (dry) {
        memcpy(out->data, dry->data, sizeof(int16_t) * AUDIO_SAMPLES_PER_BLOCK);
    }
    // Set the output volume
    //gainAdjust(out, out, m_volume, 1);
    gainAdjust(out, out, m_volume/4.0f, 2);
}

void PlateReverb::reverb(float value)
{
    m_reverb = value;
    size(m_reverb);
}
void PlateReverb::tone(float value) {
    m_tone = value;
    lowpass(m_tone);
}
void PlateReverb::wetmix(float value)
{
    m_wetmix = value;
}
void PlateReverb::echo(float value)
{
    m_echo = value;
    diffusion(1.0f - m_echo);  // echo = 1.0 is actually no echo
}
void PlateReverb::lowcut(float value)
{
    m_lowcut = value;
    lodamp(m_lowcut);
}
void PlateReverb::highcut(float value)
{
    m_highcut = value;
    hidamp(m_highcut);
}

void PlateReverb::volume(float value)
{
    volumeDb(-40.0f + (value * 50.0f)); // volume knob goes from -40dB to +10dB
}

void PlateReverb::outputmode(float value)
{
    m_outputmode = value;
}

// Other private functions
void PlateReverb::size(float n)
{
    n = constrain(n, 0.0f, 1.0f);
    n = map (n, 0.0f, 1.0f, 0.2f, rv_time_k_max);
    float32_t attn = 0.5f * map(n, 0.0f, rv_time_k_max, 0.5f, 1.0f);
    //__disable_irq();
    rv_time_k = n;
    input_attn = attn;
        //__enable_irq();
}

void PlateReverb::hidamp(float n)
{
    n = constrain(n, 0.0f, 1.0f);
    //__disable_irq();
    lp_hidamp_k = 1.0f - n;
    // __enable_irq();
}

void PlateReverb::lodamp(float n)
{
    n = constrain(n, 0.0f, 1.0f);
    //__disable_irq();
    lp_lodamp_k = -n;
    rv_time_scaler = 1.0f - n * 0.12f;        // limit the max reverb time, otherwise it will clip
    //__enable_irq();
}

void PlateReverb::lowpass(float n)
{
    n = constrain(n, 0.0f, 1.0f);
    n = map(n*n*n, 0.0f, 1.0f, 0.05f, 1.0f);
    master_lowpass_f = n;
}

void PlateReverb::diffusion(float n)
{
    n = constrain(n, 0.0f, 1.0f);
    n = map(n, 0.0f, 1.0f, 0.005f, 0.65f);
    //__disable_irq();
    in_allp_k = n;
    loop_allp_k = n;
        //__enable_irq();
}


}
